// 使用 Effect 实现斐波那契数列的 TCO
// expect: ok int 55

// 定义尾调用 effect（携带三个参数：计数器、前两个斐波那契数）
interface FibTailCall {
    fn call(n: int, a: int, b: int) -> int;
}

// 尾递归风格的斐波那契实现
// n: 还需要迭代多少次
// a: 当前斐波那契数 F(i)
// b: 下一个斐波那契数 F(i+1)
fn fib_tail(n: int, a: int, b: int) -> int {
    if n <= 0 {
        a  // 返回当前值
    } else {
        // 执行 effect: 下一次迭代时，F(i+1) 变成新的 a，F(i) + F(i+1) 变成新的 b
        @FibTailCall.call(n - 1, b, a + b)
    }
}

// TCO 循环处理器
fn fibonacci(target: int) -> int {
    let n = target;
    let a = 0;  // F(0) = 0
    let b = 1;  // F(1) = 1
    let result = 0;
    let done = false;

    while !done {
        let _ = match fib_tail(n, a, b) {
            @FibTailCall.call(next_n, next_a, next_b) => {
                n = next_n;
                a = next_a;
                b = next_b;
                0
            }
            value => {
                result = value;
                done = true;
                0
            }
        };
    };

    result
}

fn main() -> int {
    // 计算第 10 个斐波那契数
    // F(0)=0, F(1)=1, F(2)=1, F(3)=2, F(4)=3, F(5)=5,
    // F(6)=8, F(7)=13, F(8)=21, F(9)=34, F(10)=55
    fibonacci(10)
}
