// 20 - Associated Types
//
// Associated types allow interfaces to define output types that are determined
// by the implementing type, without requiring the interface itself to be generic.

// ===== Basic Associated Type =====

// Iterator interface with associated Item type
// interface Iterator {
//     type Item;
//     fn next() -> Option<Self::Item>;
// }

use core::iter::Iterator;

// Range iterator yields integers
struct Range {
    current: int,
    end: int,
}

impl Iterator for Range {
    type Item = int;

    fn next() -> Option<int> {
        if self.current < self.end {
            let value = self.current;
            self.current = self.current + 1;
            Option::Some(value)
        } else {
            Option::None
        }
    }
}

// String lines iterator yields strings
struct Lines {
    remaining: [string],
    index: int,
}

impl Iterator for Lines {
    type Item = string;

    fn next() -> Option<string> {
        let len = core::intrinsics::array_len(self.remaining);
        if self.index < len {
            let item = self.remaining[self.index];
            self.index = self.index + 1;
            Option::Some(item)
        } else {
            Option::None
        }
    }
}

// ===== Using Associated Types in Generic Functions =====

// Generic function that works with any iterator
// Uses qualified projection: Iterator::Item<T>
fn first<T: Iterator>(it: T) -> Option<Iterator::Item<T>> {
    it.next()
}

fn collect_three<T: Iterator>(it: T) -> [Iterator::Item<T>] {
    let result = [];
    match it.next() {
        Option::Some(v1) => {
            core::intrinsics::array_push(result, v1);
            match it.next() {
                Option::Some(v2) => {
                    core::intrinsics::array_push(result, v2);
                    match it.next() {
                        Option::Some(v3) => {
                            core::intrinsics::array_push(result, v3);
                        }
                        Option::None => {}
                    }
                }
                Option::None => {}
            }
        }
        Option::None => {}
    }
    result
}

// ===== Interface Values with Associated Type Bindings =====

fn consume_int_iterator(iter: Iterator{Item = int}) -> int {
    let sum = 0;
    loop {
        match iter.next() {
            Option::Some(val) => {
                sum = sum + val;
            }
            Option::None => {
                break;
            }
        }
    }
    sum
}

// ===== Associated Types with Self =====

interface Clone {
    fn clone() -> Self;
}

interface CloneEq: Clone {
    fn eq(other: Self) -> bool;

    // Default method that uses Self-only methods (clone, eq)
    // This method is dyn-safe because its signature doesn't mention Self
    fn is_clone_equal() -> bool {
        self.clone().eq(self)
    }
}

struct Counter { count: int }

impl CloneEq for Counter {
    fn clone() -> Self {
        Counter { count: self.count }
    }
    fn eq(other: Self) -> bool {
        self.count == other.count
    }
}

fn main() -> int {
    // ===== Using concrete iterators =====

    let range = Range { current: 0, end: 5 };
    std::println("Range iterator:");
    loop {
        match range.next() {
            Option::Some(val) => {
                std::println(f"  {val}");
            }
            Option::None => {break;}
        }
    }

    let lines = Lines {
        remaining: ["first", "second", "third"],
        index: 0,
    };
    std::println("Lines iterator:");
    loop {
        match lines.next() {
            Option::Some(line) => {
                std::println(f"  {line}");
            }
            Option::None => {break;}
        }
    }

    // ===== Using generic functions with associated types =====

    let range2 = Range { current: 10, end: 15 };
    match first(range2) {
        Option::Some(val) => {
            std::println(f"First element: {val}");
        }
        Option::None => {
            std::println("Empty iterator");
        }
    }

    let range3 = Range { current: 100, end: 103 };
    let collected = collect_three(range3);
    std::println(f"Collected {core::intrinsics::array_len(collected)} elements");

    // ===== Interface value with binding =====

    let range4 = Range { current: 1, end: 4 };
    let iter_obj: Iterator{Item = int} = range4 as Iterator{Item = int};
    let sum = consume_int_iterator(iter_obj);
    std::println(f"Sum: {sum}");

    // ===== Self type and associated types =====

    let c1 = Counter { count: 42 };
    let c2 = c1.clone();
    std::println(f"Counter cloned: {c2.count}");
    std::println(f"Are equal: {c1.eq(c2)}");

    0
}
