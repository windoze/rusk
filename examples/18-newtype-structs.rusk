// 18 - New-Type Structs
//
// New-type structs are nominal wrapper types around a single field.
// They provide type safety without runtime overhead.

// Define new-type structs for domain-specific types
struct UserId(int);
struct FileFd(int);
struct Meters(int);
struct Seconds(float);

// Generic new-type struct
struct Box<T>(T);

// New-type structs prevent accidental mixing of values
fn process_user(id: UserId) -> int {
    std::println(f"Processing user {id.0}");
    id.0
}

fn process_file(fd: FileFd) -> int {
    std::println(f"Processing file {fd.0}");
    fd.0
}

// Pattern matching with new-type structs
fn extract_user_id(id: UserId) -> int {
    match id {
        UserId(n) => n
    }
}

// New-type structs in data structures
struct UserRecord {
    id: UserId,
    name: string,
}

fn main() -> int {
    // Construction with call syntax
    let user_id = UserId(42);
    let file_fd = FileFd(3);

    // Access the wrapped field with .0
    std::println(f"User ID: {user_id.0}");
    std::println(f"File FD: {file_fd.0}");

    // Type safety: cannot mix different new-type structs
    // process_user(file_fd);  // Error: type mismatch!

    let result = process_user(user_id);

    // Pattern destructuring
    let UserId(raw_id) = UserId(100);
    std::println(f"Extracted ID: {raw_id}");

    // Generic new-type struct
    let boxed_int = Box(123);
    let boxed_str = Box::<string>("hello");
    std::println(f"Boxed int: {boxed_int.0}");
    std::println(f"Boxed str: {boxed_str.0}");

    // New-type structs in records
    let user = UserRecord {
        id: UserId(999),
        name: "Alice",
    };
    std::println(f"User: {user.name} (ID: {user.id.0})");

    // Measurement types prevent unit confusion
    let distance = Meters(1000);
    let time = Seconds(60.0);
    std::println(f"Distance: {distance.0}m in {time.0}s");

    result
}
