// 19 - Destructuring Patterns
//
// Rusk supports destructuring in let/const/readonly statements,
// allowing you to extract multiple values in a single declaration.

struct Point { x: int, y: int }
struct Person { name: string, age: int, city: string }
struct Wrapper<T>(T);

fn main() -> int {
    // ===== Tuple Destructuring =====

    // Basic tuple destructuring
    let (a, b) = (10, 20);
    std::println(f"a = {a}, b = {b}");

    // Nested tuples
    let ((x, y), z) = ((1, 2), 3);
    std::println(f"x = {x}, y = {y}, z = {z}");

    // Rest patterns - ignore middle elements
    let (first, .., last) = (1, 2, 3, 4, 5);
    std::println(f"first = {first}, last = {last}");

    // Rest patterns - capture middle elements
    let (head, ..tail) = (10, 20, 30, 40);
    std::println(f"head = {head}, tail has {core::intrinsics::array_len(tail)} elements");

    // ===== Array Destructuring =====

    let [first_el, ..rest_els] = [1, 2, 3, 4, 5];
    std::println(f"first element = {first_el}");

    let [.., last_el] = [10, 20, 30];
    std::println(f"last element = {last_el}");

    // ===== Struct Destructuring =====

    // Named-field struct with field renaming
    let Point { x: px, y: py } = Point { x: 100, y: 200 };
    std::println(f"point: ({px}, {py})");

    // Field shorthand
    let Point { x, y } = Point { x: 5, y: 10 };
    std::println(f"x = {x}, y = {y}");

    // Partial destructuring with ..
    let Person { name, .. } = Person {
        name: "Alice",
        age: 30,
        city: "Beijing",
    };
    std::println(f"name = {name}");

    // ===== New-Type Struct Destructuring =====

    struct UserId(int);
    let UserId(id) = UserId(42);
    std::println(f"user id = {id}");

    let Wrapper(value) = Wrapper(999);
    std::println(f"wrapped value = {value}");

    // ===== Enum Destructuring =====

    enum Result<T, E> { Ok(T), Err(E) }

    let Result::Ok(val) = Result::Ok(123);
    std::println(f"result value = {val}");

    // ===== Const and Readonly Destructuring =====

    // const: bindings cannot be reassigned
    const (ca, cb) = (100, 200);
    std::println(f"const: ca = {ca}, cb = {cb}");
    // ca = 999;  // Error: cannot reassign const binding

    // readonly: bindings cannot be reassigned AND prevent mutation
    readonly (arr1, arr2) = ([1, 2, 3], [4, 5, 6]);
    std::println(f"readonly arrays created");
    // arr1[0] = 999;  // Error: mutation through readonly view

    // ===== Complex Nested Patterns =====

    struct Container {
        data: (int, int),
        meta: string,
    }

    let Container { data: (d1, d2), meta } = Container {
        data: (111, 222),
        meta: "example",
    };
    std::println(f"data: ({d1}, {d2}), meta: {meta}");

    // Combining arrays and tuples
    let [(ax, ay), (bx, by)] = [(1, 2), (3, 4)];
    std::println(f"points: ({ax},{ay}), ({bx},{by})");

    0
}
