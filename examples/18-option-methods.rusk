// 18 - `Option` 常用方法（组合子）
//
// `Option<T>` 用来表达“可能有值 / 可能没有值”，并提供了一组非常实用的方法：
// - `map`：只在 `Some(v)` 时变换 `v`
// - `and_then`：把返回 `Option` 的步骤串起来（避免层层 match）
// - `unwrap_or` / `unwrap_or_else`：提供默认值（后者惰性计算）
//
// 对比（Rust）：
//   option.map(...).and_then(...).unwrap_or(...)

use core::len::Len;

fn divide(a: int, b: int) -> Option<int> {
    if b == 0 {
        Option::None
    } else {
        Option::Some(a / b)
    }
}

fn parse_positive(s: string) -> Option<int> {
    // 简化版解析器：这里只用硬编码值演示 Option 的用法
    if s == "42" {
        Option::Some(42)
    } else if s == "100" {
        Option::Some(100)
    } else {
        Option::None
    }
}

// 安全访问：把“可能越界”变成 `Option`
fn safe_get(arr: [int], idx: int) -> Option<int> {
    let len = arr.len();
    if idx >= 0 && idx < len {
        Option::Some(arr[idx])
    } else {
        Option::None
    }
}

fn main() -> int {
    // ===== is_some / is_none =====

    let some_value = Option::Some(42);
    let none_value = Option::None;

    std::println(f"some_value.is_some() = {some_value.is_some()}");
    std::println(f"some_value.is_none() = {some_value.is_none()}");
    std::println(f"none_value.is_some() = {none_value.is_some()}");
    std::println(f"none_value.is_none() = {none_value.is_none()}");

    // ===== map：只变换 Some 内部的值 =====

    let doubled = Option::Some(21).map(|x: int| { x * 2 });
    match doubled {
        Option::Some(v) => {
            std::println(f"Doubled: {v}");
        }
        Option::None => {
            std::println("No value");
        }
    }

    // 对 None 做 map 仍然是 None
    let none_mapped = none_value.map(|x: int| { x * 2 });
    std::println(f"None mapped is_none: {none_mapped.is_none()}");

    // ===== and_then：串联“返回 Option 的步骤” =====

    let result1 = divide(20, 2).and_then(|x: int| {
        divide(x, 5)
    });
    match result1 {
        Option::Some(v) => {
            std::println(f"20 / 2 / 5 = {v}");
        }
        Option::None => {
            std::println("Division failed");
        }
    }

    // and_then：遇到 None 会短路
    let result2 = divide(20, 0).and_then(|x: int| {
        divide(x, 5)
    });
    std::println(f"20 / 0 / 5 failed: {result2.is_none()}");

    // ===== unwrap：取出 Some 的值，否则 panic =====

    let safe_unwrap = Option::Some(99).unwrap();
    std::println(f"Unwrapped: {safe_unwrap}");

    // 下面这行会 panic（示例里注释掉）：
    // let panic_unwrap = Option::None.unwrap();

    // ===== unwrap_or：提供默认值 =====

    let with_default = Option::Some(42).unwrap_or(100);
    std::println(f"Some with default: {with_default}");

    let none_with_default = none_value.unwrap_or(100);
    std::println(f"None with default: {none_with_default}");

    // ===== unwrap_or_else：惰性计算默认值 =====

    let lazy_default = Option::Some(42).unwrap_or_else {
        std::println("Computing default (not called for Some)");
        999
    };
    std::println(f"Result with lazy default: {lazy_default}");

    let none_lazy_default = none_value.unwrap_or_else {
        std::println("Computing default for None");
        999
    };
    std::println(f"None with lazy default: {none_lazy_default}");

    // ===== 组合：把多个步骤串起来 =====

    let chain_result = parse_positive("42")
        .map(|x: int| { x * 2 })
        .and_then(|x: int| { divide(x, 4) })
        .unwrap_or(0);

    std::println(f"Chained operations result: {chain_result}");

    // ===== 小例子：安全数组访问 =====

    let numbers = [10, 20, 30, 40, 50];
    let len = numbers.len();

    match safe_get(numbers, 2) {
        Option::Some(v) => {
            std::println(f"numbers[2] = {v}");
        }
        Option::None => {
            std::println("Index out of bounds");
        }
    }

    let out_of_bounds = safe_get(numbers, 100).unwrap_or(-1);
    std::println(f"Out of bounds access with default: {out_of_bounds}");

    // ===== 多个 Option 的组合 =====

    let a = Option::Some(10);
    let b = Option::Some(20);
    let c = Option::None;

    // 两个 Some：可以组合出一个 Some
    let sum = a.and_then(|x: int| {
        b.map(|y: int| { x + y })
    });

    match sum {
        Option::Some(v) => {
            std::println(f"Sum of two Some values: {v}");
        }
        Option::None => {
            std::println("One or both values were None");
        }
    }

    // 只要有一个是 None，结果就是 None
    let sum_with_none = a.and_then(|x: int| {
        c.map(|y: int| { x + y })
    });

    std::println(f"Sum with None is_none: {sum_with_none.is_none()}");

    0
}
