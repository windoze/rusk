// 21 - byte, char, and String/Bytes Slicing
//
// Rusk provides byte and char primitive types, along with zero-copy
// slicing operations for strings and bytes.

fn main() -> int {
    // ===== byte type =====

    // Convert int to byte (truncating)
    let b1 = 65.to_byte();  // 'A' in ASCII
    std::println(f"byte value: {b1.to_int()}");

    // Truncating conversion: keeps low 8 bits
    let b2 = 256.to_byte();  // wraps to 0
    let b3 = 257.to_byte();  // wraps to 1
    std::println(f"256 as byte: {b2.to_int()}, 257 as byte: {b3.to_int()}");

    // Checked conversion
    match 65.try_byte() {
        Option::Some(b) => {
            std::println(f"65 is a valid byte: {b.to_int()}");
        }
        Option::None => {
            std::println("Invalid byte");
        }
    }

    match (-1).try_byte() {
        Option::Some(b) => {
            std::println(f"Got byte: {b.to_int()}");
        }
        Option::None => {
            std::println("-1 is not a valid byte (out of range)");
        }
    }

    // ===== char type =====

    // Convert int to char (Unicode scalar value)
    let c1 = 65.to_char();  // 'A'
    std::println(f"char value: U+{c1.to_int()}");

    // Chinese character
    let c2 = 0x4E2D.to_char();  // '中'
    std::println(f"Chinese char: U+{c2.to_int()}");

    // Checked conversion
    match 0x1F600.try_char() {
        Option::Some(c) => {
            std::println(f"Emoji codepoint: U+{c.to_int()}");
        }
        Option::None => {
            std::println("Invalid character");
        }
    }

    // Surrogate values are invalid
    match 0xD800.try_char() {
        Option::Some(c) => {
            std::println(f"Got char: U+{c.to_int()}");
        }
        Option::None => {
            std::println("0xD800 is not a valid char (surrogate range)");
        }
    }

    // ===== bytes operations =====

    let data = b"\x48\x65\x6C\x6C\x6F";  // "Hello" in bytes

    // Indexing bytes (O(1))
    let first_byte = data[0];
    std::println(f"First byte: {first_byte.to_int()}");

    // Safe access with get
    match core::intrinsics::bytes_get(data, 0) {
        Option::Some(b) => {
            std::println(f"Byte at index 0: {b.to_int()}");
        }
        Option::None => {
            std::println("Index out of bounds");
        }
    }

    match core::intrinsics::bytes_get(data, 100) {
        Option::Some(b) => {
            std::println(f"Byte: {b.to_int()}");
        }
        Option::None => {
            std::println("Index 100 is out of bounds");
        }
    }

    // Zero-copy slicing
    let slice1 = core::intrinsics::bytes_slice(data, 0, Option::Some(2));
    std::println("Created slice [0, 2)");

    let slice2 = core::intrinsics::bytes_slice(data, 1, Option::None);
    std::println("Created slice from index 1 to end");

    // Convert between bytes and [byte]
    let byte_array = core::intrinsics::bytes_to_array(data);
    std::println(f"Converted to array of {core::intrinsics::array_len(byte_array)} bytes");

    let new_bytes = core::intrinsics::bytes_from_array(byte_array);
    std::println("Converted array back to bytes");

    // ===== string operations =====

    let text = "Hello, 世界!";
    std::println(f"Original string: {text}");

    // Iterate over characters (yields char)
    std::println("Characters:");
    for c in text {
        let codepoint = c.to_int();
        std::println(f"  U+{codepoint}");
    }

    // Zero-copy string slicing (by byte offsets!)
    // "Hello" is 5 bytes, ", " is 2 bytes = 7 total before Chinese chars
    let hello_slice = core::intrinsics::string_slice(text, 0, Option::Some(5));
    std::println(f"Slice [0, 5): {hello_slice}");

    let from_7 = core::intrinsics::string_slice(text, 7, Option::None);
    std::println(f"Slice from byte 7: {from_7}");

    // Note: string slicing uses BYTE offsets, not character indices
    // Each Chinese character is typically 3 bytes in UTF-8
    // "世" starts at byte 7, "界" starts at byte 10

    // ===== Working with byte arrays =====

    let mut_bytes = [72.to_byte(), 105.to_byte()];  // "Hi"
    std::println(f"Mutable byte array has {core::intrinsics::array_len(mut_bytes)} elements");

    // Modify bytes
    mut_bytes[0] = 66.to_byte();  // Change 'H' to 'B'
    std::println(f"Modified first byte to {mut_bytes[0].to_int()}");

    0
}
