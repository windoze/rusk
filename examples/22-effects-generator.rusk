// 22 - 用效应实现生成器（generator）
//
// 这个示例展示如何用代数效应实现“可 yield 多次”的生成器：
// - 生成器函数内部通过 `@Yield<T>.yield(value)` 把值交给处理器
// - 处理器可以选择：
//   - 立刻 `resume(())`：继续生成下一个值
//   - 不 resume：中止/截断生成器
//
// 对比（Python）：
//   def gen(): yield 1; yield 2
//   for x in gen(): ...

interface Yield<T> { fn yield(value: T); }

fn yield<T>(value: T) {
    @Yield<T>.yield(value);
}

// 生成器：产出 [start, end) 的整数
fn range(start: int, end: int) {
    let i = start;
    while i < end {
        yield(i);
        i = i + 1;
    }
}

// 生成器：产出前 count 个斐波那契数
fn fibonacci(count: int) {
    let a = 0;
    let b = 1;
    let i = 0;

    while i < count {
        yield(a);
        let next = a + b;
        a = b;
        b = next;
        i = i + 1;
    }
}

fn main() {
    std::println("=== Range 生成器（0..5）===");
    match range(0, 5) {
        @Yield<int>.yield(value) => {
            std::println(f"  yielded: {value}");
            resume(())
        }
        result => result
    };

    std::println("\n=== Fibonacci 生成器（前 10 个）===");
    match fibonacci(10) {
        @Yield<int>.yield(value) => {
            std::println(f"  fib: {value}");
            resume(())
        }
        result => result
    };

    std::println("\n=== 在处理器里写自定义逻辑（边消费边累加）===");
    let sum = 0;
    match range(1, 6) {
        @Yield<int>.yield(value) => {
            sum = sum + value;
            std::println(f"  current value: {value}, running sum: {sum}");
            resume(())
        }
        _ => {}
    };
    std::println(f"最终 sum = {sum}");
}
