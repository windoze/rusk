// 19 - 不动点组合子（Fixed-point Combinator / Y/Z 组合子思想）
//
// 目标：用“高阶函数 + 泛型”表达递归，而不在函数体里直接写函数名。
//
// 核心思路：
// - 把“递归调用点”抽象成一个参数 `self`
// - 再用 `fix` 把 `self` 回填成“它自己”
//
// 备注：
// - 经典的 Y 组合子在严格求值 + 静态类型下会遇到一些限制，这里用一个更实用的近似形式来展示“思想”。
//
// 对比（JavaScript，伪代码）：
//   const fix = f => x => f(fix(f), x)

// `(T) -> R` 形式的一元不动点组合子
fn fix<T, R>(f: fn(fn(T) -> R, T) -> R) -> fn(T) -> R {
    |x| { f(fix(f), x) }
}

// `(T1, T2) -> R` 形式的二元不动点组合子
fn fix2<T1, T2, R>(f: fn(fn(T1, T2) -> R, T1, T2) -> R) -> fn(T1, T2) -> R {
    |x, y| { f(fix2(f), x, y) }
}

fn main() {
    std::println("=== 不动点组合子示例 ===\n");

    // 示例 1：阶乘
    std::println("1) 阶乘（factorial）：");

    let factorial_step = |self: fn(int) -> int, n: int| {
        if n <= 1 {
            1
        } else {
            n * self(n - 1)
        }
    };

    let factorial = fix(factorial_step);
    std::println(f"  factorial(5) = {factorial(5)}");
    std::println(f"  factorial(10) = {factorial(10)}");

    // 示例 2：斐波那契
    std::println("\n2) 斐波那契（fibonacci）：");

    let fib_step = |self: fn(int) -> int, n: int| {
        if n <= 1 {
            n
        } else {
            self(n - 1) + self(n - 2)
        }
    };

    let fib = fix(fib_step);
    std::println(f"  fib(0) = {fib(0)}");
    std::println(f"  fib(1) = {fib(1)}");
    std::println(f"  fib(7) = {fib(7)}");
    std::println(f"  fib(10) = {fib(10)}");

    // 示例 3：1..n 求和
    std::println("\n3) 1..n 求和：");

    let sum_step = |self: fn(int) -> int, n: int| {
        if n <= 0 {
            0
        } else {
            n + self(n - 1)
        }
    };

    let sum = fix(sum_step);
    std::println(f"  sum(1..5) = {sum(5)}");
    std::println(f"  sum(1..10) = {sum(10)}");
    std::println(f"  sum(1..100) = {sum(100)}");

    // 示例 4：最大公约数（两参数，用 fix2）
    std::println("\n4) 最大公约数（GCD）：");

    let gcd_step = |self: fn(int, int) -> int, a: int, b: int| {
        if b == 0 {
            a
        } else {
            self(b, a % b)
        }
    };

    let gcd = fix2(gcd_step);
    std::println(f"  gcd(48, 18) = {gcd(48, 18)}");
    std::println(f"  gcd(100, 35) = {gcd(100, 35)}");
    std::println(f"  gcd(17, 19) = {gcd(17, 19)}");

    std::println("\n=== 关键点 ===");
    std::println("`fix` 把“递归”抽象成一个高阶函数参数，");
    std::println("展示了泛型 + 高阶函数可以表达很强的编程模式。");
}
