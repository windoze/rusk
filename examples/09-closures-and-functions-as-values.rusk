// 09 - 闭包与函数值（`fn(...) -> ...`）
//
// 覆盖点：
// - 命名函数与“不捕获”的 lambda 都可以当作 `fn(...) -> ...` 传递
// - lambda 也可以捕获外部局部变量（形成闭包），用于构建更高阶的抽象
//
// 对比（JavaScript）：
//   const add1 = (n) => n + 1
//   function apply(f, x) { return f(x) }

fn apply(f: fn(int) -> int, x: int) -> int { f(x) }

fn main() -> int {
    let add1 = |n| { n + 1 };
    let v = apply(add1, 41);

    let total = 0;
    let push = |n: int| {
        total = total + n;
        total
    };
    push(10);
    push(20);

    std::println(f"apply(add1, 41) = {v}");
    std::println(f"captured total = {total}");

    v + total
}
