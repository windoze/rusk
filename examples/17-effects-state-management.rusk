// 17 - React-like state management with effects
//
// This example demonstrates how algebraic effects can provide a better alternative
// to React's useEffect, overcoming many of its typical restrictions:
//
// React useEffect problems:
// 1. Dependency array hell - easy to forget dependencies, causing stale closures
// 2. Cleanup complexity - must return cleanup function, easy to get wrong
// 3. Can't use async/await directly
// 4. Effects run after render - timing is indirect
// 5. Race conditions with multiple effects
//
// With algebraic effects, we can:
// 1. No dependency arrays needed - effects capture current values naturally
// 2. Automatic cleanup tracking through handlers
// 3. Direct control flow - clearer execution model
// 4. Type-safe side effects with generics
// 5. Composable effect handlers

use core::intrinsics::array_len;
use core::intrinsics::array_push;

// Effect interfaces
interface State<T> {
    fn get() -> T;
    fn set(value: T);
}

interface Subscribe<T> {
    fn subscribe(source: string) -> T;
}

interface Cleanup {
    fn on_cleanup(cleanup_fn: fn());
}

// Helper functions for cleaner syntax
fn get_state<T>() -> T {
    @State<T>.get()
}

fn set_state<T>(value: T) {
    @State<T>.set(value)
}

fn subscribe<T>(source: string) -> T {
    @Subscribe<T>.subscribe(source)
}

fn on_cleanup(cleanup_fn: fn()) {
    @Cleanup.on_cleanup(cleanup_fn)
}

// React-like effect handlers, corresponding to useState and useEffect behavior

// Handler that manages state
fn with_state<T>(initial: T, component: fn()) {
    let state = initial;

    match component() {
        @State<T>.get() => {
            resume(state)
        }
        @State<T>.set(new_value) => {
            state = new_value;
            resume(())
        }
        _ => {}
    }
}

// Handler for data subscriptions, and tracks cleanup callbacks.
//
// Note: in Rusk, effect handlers installed by `match` are scoped to the scrutinee evaluation.
// When a handler resumes a continuation, any *outer* handlers are not active in the resumed
// computation. That means effects that occur *after* `subscribe(...)` must be handled here.
fn with_subscriptions<T>(source: fn(string) -> T, component: fn()) {
    let cleanups: [fn()] = [];

    match component() {
        @Subscribe<T>.subscribe(source_name) => {
            // Simulate fetching data from source
            let data = source(source_name);
            std::println(f"  [Subscription] Fetching: {source_name}");
            resume(data)
        }
        @Cleanup.on_cleanup(cleanup_fn) => {
            array_push(cleanups, cleanup_fn);
            resume(())
        }
        _ => {}
    };

    // Run all cleanup functions
    std::println("  [Handler] Running cleanup functions...");
    for cleanup in cleanups {
        cleanup()
    }
}

// Sample components demonstrating React-like state management with effects

// Example 1: Simple counter with side effect
// In React: useEffect with dependency array [count]
// Here: Direct effect call, no dependency tracking needed
fn counter_component() {
    let count: int = get_state();
    std::println(f"Counter component render: count = {count}");

    set_state(count + 1);

    count = get_state();
    std::println(f"  Updated count: {count}");
}

// Example 2: Subscription with automatic cleanup
// In React: useEffect with cleanup function return
// Here: Explicit cleanup registration, tracked by handler
fn subscription_component() {
    std::println("\nSubscription component:");

    // Subscribe to data source
    let data: string = subscribe("user-data");
    std::println(f"  Received data: {data}");

    // Register cleanup - will be called when component unmounts
    on_cleanup {
        std::println("  [Cleanup] Unsubscribing from user-data")
    };

    std::println(f"  Processing: {data}")
}

// Example 3: Multiple effects compose naturally
// In React: Multiple useEffect calls can race or conflict
// Here: Clear sequential execution, explicit ordering
fn complex_component() {
    std::println("\nComplex component with multiple effects:");

    let user_id: int = get_state();
    std::println(f"  User ID: {user_id}");

    // Effect 1: Fetch user data
    let user_name: string = subscribe(f"user/{user_id}");
    on_cleanup {
        std::println(f"  [Cleanup 1] Cancel user/{user_id} subscription")
    };

    // Effect 2: Fetch user posts (depends on user data)
    // In React: This dependency is tricky with useEffect
    // Here: Natural sequential flow
    let posts: string = subscribe(f"posts/{user_name}");
    on_cleanup {
        std::println(f"  [Cleanup 2] Cancel posts/{user_name} subscription")
    };

    std::println(f"  Loaded user: {user_name}");
    std::println(f"  Loaded posts: {posts}");
}

// Sample data source function
fn sample_string_source(source_name: string) -> string {
    std::println(f"    (Simulated fetch from {source_name})");
    f"data-from-{source_name}"
}

fn main() {
    std::println("=== React-like State Management with Effects ===\n");

    std::println("Example 1: Counter (no dependency array needed)");
    with_state(0) {
        counter_component()
    };

    std::println("\n==================================================");

    std::println("\nExample 2: Subscription with auto cleanup");
    with_subscriptions(sample_string_source) {
        subscription_component()
    };

    std::println("\n==================================================");

    std::println("\nExample 3: Complex component with multiple effects");
    with_state(123) {
        with_subscriptions(sample_string_source) {
            complex_component()
        }
    };

    std::println("\n=== Key Advantages ===");
    std::println("1. No dependency arrays - values captured naturally");
    std::println("2. Explicit cleanup registration - harder to forget");
    std::println("3. Clear execution order - no hidden timing issues");
    std::println("4. Type-safe effects with generics");
    std::println("5. Effects compose naturally without conflicts");
}
