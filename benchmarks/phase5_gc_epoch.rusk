// Microbenchmark for Phase 5 (GC mark epoch).
//
// The intent is to create a large heap high-water mark, then trigger many GC cycles while the
// heap slot table stays large. With "mark epoch", the collector avoids clearing mark bits by
// scanning the entire slot array each cycle.
//
// Expected return: 200001

fn main() -> int {
    // Phase A: grow the heap to a large high-water mark by keeping allocations alive.
    let grown = {
        let keep = [(0, 0)];
        let i = 0;
        while i < 200000 {
            core::intrinsics::array_push(keep, (i, i + 1));
            i = i + 1;
        };
        core::intrinsics::array_len(keep)
    };

    // Phase B: churn allocations to force lots of GC cycles, while the heap slot table is large.
    let cycle = 0;
    while cycle < 100 {
        let j = 0;
        while j < 20000 {
            let _t = (j, j + 1);
            j = j + 1;
        };
        cycle = cycle + 1;
    };

    grown
}

