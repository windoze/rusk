use std::path::PathBuf;

/// A host function signature used by the compiler front-end.
///
/// Host signatures are used for:
/// - validating declared host imports in user code and sysroot modules
/// - lowering host calls into MIR/bytecode with an ABI-safe boundary
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct HostFnSig {
    /// Parameter types.
    pub params: Vec<HostType>,
    /// Return type.
    pub ret: HostType,
}

/// A value type available at the VM/host boundary.
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum HostType {
    /// A dynamically typed value. Used when a more precise type is not available.
    Any,
    Unit,
    Bool,
    Int,
    Float,
    String,
    Bytes,
    /// A runtime type representation (`typerep`), used by some core intrinsics.
    TypeRep,
    Array(Box<HostType>),
    Tuple(Vec<HostType>),
}

/// Visibility of a host-declared item (function/module).
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum HostVisibility {
    /// Not exported; only usable within the declaring module.
    Private,
    /// Exported; usable from other modules.
    Public,
}

/// A declared host function in a host module.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct HostFunctionDecl {
    /// Function visibility.
    pub visibility: HostVisibility,
    /// Module-local function name (e.g. `"println"`).
    pub name: String,
    /// Function signature.
    pub sig: HostFnSig,
}

/// A host module declaration made available to the compiler during compilation.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct HostModuleDecl {
    /// Module visibility.
    pub visibility: HostVisibility,
    /// Functions declared by this module.
    pub functions: Vec<HostFunctionDecl>,
}

/// A declaration of an externalized effect operation (for bytecode v0).
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ExternalEffectDecl {
    /// Effect interface name (e.g. `"console::IO"`).
    pub interface: String,
    /// Effect method name (e.g. `"print"`).
    pub method: String,
    /// Operation signature.
    pub sig: HostFnSig,
}

/// Compilation options for the script front-end.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct CompileOptions {
    /// Peephole optimization level to apply to generated bytecode.
    pub opt_level: rusk_bytecode::OptLevel,
    /// Optional sysroot directory. When not set, the compiler tries:
    /// - `$RUSK_SYSROOT`
    /// - `./sysroot` (current working directory)
    /// - `../../sysroot` relative to the `rusk-compiler` crate directory
    pub sysroot: Option<PathBuf>,
    /// Whether to load `sysroot/std` (if present).
    pub load_std: bool,
    /// Declared host modules available for import (name -> declaration).
    pub host_modules: Vec<(String, HostModuleDecl)>,
    /// Declared external effects available for `perform`/`resume` at runtime.
    pub external_effects: Vec<ExternalEffectDecl>,
}

impl Default for CompileOptions {
    fn default() -> Self {
        Self {
            opt_level: rusk_bytecode::OptLevel::default(),
            sysroot: None,
            load_std: true,
            host_modules: Vec::new(),
            external_effects: Vec::new(),
        }
    }
}

impl CompileOptions {
    /// Registers a host module declaration under `module_name`.
    ///
    /// Host modules are used to back sysroot-provided functionality and/or embedder-provided APIs.
    pub fn register_host_module(
        &mut self,
        module_name: impl Into<String>,
        module: HostModuleDecl,
    ) -> Result<(), String> {
        let module_name = module_name.into();
        if module_name.is_empty() {
            return Err("host module name cannot be empty".to_string());
        }
        if module_name.contains("::") {
            return Err(format!(
                "nested host modules are not supported: `{module_name}` contains `::`"
            ));
        }
        if self
            .host_modules
            .iter()
            .any(|(name, _)| name == &module_name)
        {
            return Err(format!("duplicate host module `{module_name}`"));
        }
        self.host_modules.push((module_name, module));
        Ok(())
    }

    /// Registers an external effect operation declaration.
    ///
    /// The compiler uses this to assign stable `EffectId`s and to validate ABI safety for the
    /// bytecode v0 boundary.
    pub fn register_external_effect(
        &mut self,
        interface: impl Into<String>,
        method: impl Into<String>,
        sig: HostFnSig,
    ) -> Result<(), String> {
        let interface = interface.into();
        let method = method.into();
        if interface.is_empty() {
            return Err("external effect interface name cannot be empty".to_string());
        }
        if method.is_empty() {
            return Err("external effect method name cannot be empty".to_string());
        }
        if self
            .external_effects
            .iter()
            .any(|e| e.interface == interface && e.method == method)
        {
            return Err(format!(
                "duplicate external effect declaration `{interface}.{method}`"
            ));
        }
        self.external_effects.push(ExternalEffectDecl {
            interface,
            method,
            sig,
        });
        Ok(())
    }
}
