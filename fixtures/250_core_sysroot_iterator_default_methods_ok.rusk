// expect: ok int 151

use core::iter::Iterator;

struct ArrayIter<T> { arr: [T], idx: int }

impl<T> Iterator for ArrayIter<T> {
    type Item = T;

    fn next() -> Option<T> {
        if self.idx < self.arr.len() {
            let out = self.arr[self.idx];
            self.idx = self.idx + 1;
            Option::Some(out)
        } else {
            Option::None
        }
    }
}

fn main() -> int {
    let it1 = ArrayIter { arr: [10, 20, 30, 40], idx: 0 };
    let nth = it1.nth(2);

    let it2 = ArrayIter { arr: [1, 2, 3], idx: 0 };
    let last = it2.last();

    let it3 = ArrayIter { arr: [1, 2, 3, 4, 5], idx: 0 };
    let cnt = it3.count();

    let it4 = ArrayIter { arr: [1, 2, 3, 4], idx: 0 };
    let found = it4.find(|x: int| { x == 3 });

    let it5 = ArrayIter { arr: [1, 2, 3], idx: 0 };
    let any = it5.any(|x: int| { x > 2 });

    let it6 = ArrayIter { arr: [1, 2, 3], idx: 0 };
    let all = it6.all(|x: int| { x < 4 });

    let bonus1 = if any { 10 } else { 0 };
    let bonus2 = if all { 100 } else { 0 };

    let it7 = ArrayIter { arr: [1, 2], idx: 0 };
    let neg = it7.nth(-1);

    match (nth, last, found, neg) {
        (Option::Some(a), Option::Some(b), Option::Some(c), Option::None) => {
            a + b + c + bonus1 + bonus2 + cnt
        }
        _ => 0,
    }
}
