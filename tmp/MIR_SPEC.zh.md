# Rusk MIR 规范 (v0.2 草案)

本文档定义了 Rusk 的中级中间表示（MIR）。MIR 是一个控制流图（CFG），具有显式的基本块和显式的效应处理（`push_handler` / `perform` / `resume`）。v0.2 的设计目标是：

- **自包含且精确**：每条指令和终结符都有定义的操作语义，包括陷阱（trap）。
- **解释器友好**：该 IR 可以通过一个小型运行时直接执行。
- **降级友好**：将 Rusk 构造（`match`、效应、循环）降级到 MIR 是很直接的。

本规范侧重于**动态解释语义**。实现可以自由地添加静态检查/验证（类型、移动跟踪、支配性等）作为附加层。

---

## 1. 目标

- **结构化 CFG**：用于快速执行的显式基本块和终结符。
- **效应感知**：处理器和 `perform`/`resume` 是一等 IR 操作。
- **低开销循环**：循环不需要隐式闭包分配。
- **语言对齐**：直接从 Rusk 语法和语义降级。

---

## 2. 约定

### 2.1 确定性

MIR 执行在以下条件下是确定性的：
- 入口函数的初始参数，以及
- 确定性的宿主函数。

所有指令按**从左到右**的顺序求值操作数。

### 2.2 标识符

MIR 在其规范文本格式中使用以下标识符形式（非规范但推荐）：

- **函数名**：`<ident>`（例如 `main`、`process_data`）
- **块标签**：`<ident>`（例如 `block0`、`block_log`）
- **局部变量**：`%<ident>`（例如 `%0`、`%msg`、`%k`）
- **接口方法**：`<Interface>.<method>`（例如 `Logger.log`）

实现可以对这些名称进行内部化。

---

## 3. 程序结构

### 3.1 模块

模块包含：
- 函数（必需）
- 可选的接口/类型元数据（可选，用于工具/验证/优化）
- 可选的方法解析元数据（可选，用于 `vcall`）

### 3.2 函数

函数体是基本块的 CFG：

```text
fn <name>(<params...>) -> <ret> {
  <block>...
}
```

**入口块**是函数体中定义的第一个块（按文本顺序）。按照惯例，它被命名为 `block0`。

参数是局部变量加上可选的可变性/类型信息：

```text
fn f(readonly %x: int, %y: array) -> unit { ... }
```

### 3.3 基本块

基本块具有：
- 标签（块名）
- 可选的参数列表（块参数）
- 指令列表
- 单个终结符

```text
block1(%x, %y):
  %z = copy %x
  return %z
```

当控制转移到块中时，块参数被赋值。

---

## 4. 值、局部变量和可变性

### 4.1 运行时值模型

MIR 值在运行时是动态类型的。v0.2 要求支持：

- `unit`
- `bool`
- `int`（有符号 64 位，二进制补码）
- `float`（IEEE-754 binary64）
- `string`（UTF-8）
- `bytes`（不透明字节向量）
- 引用值：
  - `struct` 实例
  - `enum` 实例
  - `array` 实例
- `fn` 引用（用于 `icall`）
- 延续令牌（用于 `resume`）

引用值具有**标识**（两个引用可能指向同一个对象）。

### 4.2 局部变量

局部变量是每个函数的槽位。每个槽位可能是：
- **未初始化**
- **已初始化**，带有一个值

读取未初始化的局部变量是陷阱。

### 4.3 复制 vs 移动

MIR 有显式的 `copy` 和 `move`。

- `copy` 读取源局部变量并将值克隆到目标。
  - 对于引用值，`copy` 创建一个指向同一对象的**新引用**（它不深度克隆对象）。
- `move` 读取源局部变量，将其写入目标，并使源局部变量**未初始化**。

实现可以添加额外的动态或静态诊断（例如，移动后使用），但上述操作语义是规范的。

### 4.4 只读视图

Rusk 支持 `readonly` 绑定作为**视图限制**（不一定是深度冻结）。MIR 通过允许引用被标记为只读来对此建模。

- 通过只读引用进行的任何写入都会陷阱。
- 只读是**每个引用视图**的；其他别名可能仍然是可变的。

MIR 提供 `as_readonly` 来创建只读视图。

---

## 5. 类型（可选）

MIR 可以携带类型用于优化/调试：

- 原始类型：`int`、`float`、`bool`、`string`、`bytes`、`unit`
- 复合类型：`struct`、`enum`、`array`
- 可调用：`fn`
- 效应：`interface`

类型检查是可选的；符合规范的解释器动态执行。

---

## 6. 操作数、字面量和模式

### 6.1 操作数

操作数可以是：
- 局部变量：`%x`
- 字面量：例如 `unit`、`true`、`123`、`"text"`、`[1, 2, 3]`

### 6.2 字面量

字面量可以嵌套：
- 数组字面量：`[<lit>, ...]`
- 结构体字面量：`Type { field: <lit>, ... }`
- 枚举字面量：`Enum::Variant(<lit>, ...)`

复合字面量在求值时分配新的引用值。

### 6.3 模式（用于 `switch` 和处理器子句）

模式是 Rusk 模式的受限子集。

支持的形式：
- `_`（通配符）
- `bind`（绑定位置；文本形式使用局部变量，例如 `%msg`）
- 字面量：`unit`、`true`、`123`、`"s"`、`b\"...\"`
- 枚举解构：`Enum::Variant(<pat>, ...)`
- 结构体解构：`Type { field: <pat>, ... }`
- 数组前缀：`[<pat>, <pat>, ..]`

模式匹配对复合值是结构性的。对于结构体模式：
- 缺失字段在**匹配时陷阱**（实现允许将其视为不匹配，但 v0.2 建议陷阱以便早期暴露无效的 MIR）。

绑定顺序是**从左到右，深度优先**。

类映射构造的确定性规则：
- 对于结构体模式，字段按照它们在模式中出现的**文本顺序**处理。

当模式用于 `switch` 或处理器子句时：
- 绑定值的序列（按绑定顺序）作为块参数传递给所选目标块
- 目标块必须声明恰好该数量的块参数（名称用于可读性；arity 是规范的）

---

## 7. 指令

指令以赋值形式编写：

```text
%dst = <op> ...
```

一些指令类似语句，不产生值。

### 7.1 常量和绑定

- `const`：
  - 语法：`%dst = const <literal>`
  - 语义：求值字面量，写入 `%dst`。

- `copy`：
  - 语法：`%dst = copy %src`
  - 语义：读取 `%src`，克隆，写入 `%dst`。
  - 陷阱：`%src` 未初始化。

- `move`：
  - 语法：`%dst = move %src`
  - 语义：读取 `%src`，写入 `%dst`，将 `%src` 设置为未初始化。
  - 陷阱：`%src` 未初始化。

- `as_readonly`：
  - 语法：`%dst = as_readonly %src`
  - 语义：如果 `%src` 是引用，创建只读视图；否则复制。
  - 陷阱：`%src` 未初始化。

### 7.2 数据和字段

- `make_struct`：
  - 语法：`%dst = make_struct <Type> { field: <op>, ... }`
  - 语义：分配一个结构体实例并将引用写入 `%dst`。
  - 操作数求值顺序：字段操作数按**文本字段顺序从左到右**求值。

- `make_array`：
  - 语法：`%dst = make_array [ <op>, <op>, ... ]`
  - 语义：分配一个数组实例并将引用写入 `%dst`。
  - 操作数求值顺序：元素按**从左到右**求值。

- `make_enum`：
  - 语法：`%dst = make_enum <Enum>::<Variant>(<op>, <op>, ...)`
  - 语义：分配一个枚举实例并将引用写入 `%dst`。
  - 操作数求值顺序：字段按**从左到右**求值。

- `get_field`：
  - 语法：`%dst = get_field <op_obj> <field>`
  - 陷阱：非结构体，缺失字段。

- `set_field`：
  - 语法：`set_field <op_obj> <field> <op_val>`
  - 陷阱：只读引用，非结构体，缺失字段。

- `index_get`：
  - 语法：`%dst = index_get <op_arr> <op_idx>`
  - 陷阱：非数组，非 int 索引，越界。

- `index_set`：
  - 语法：`index_set <op_arr> <op_idx> <op_val>`
  - 陷阱：只读引用，非数组，非 int 索引，越界。

- `len`：
  - 语法：`%dst = len <op_arr>`
  - 陷阱：非数组。

### 7.3 调用

- `call`（直接）：
  - 语法：`%dst = call <fn_name> (<op_args...>)`
  - 语义：按名称调用 MIR 函数或宿主函数。
  - 约定：`%dst` 可以写作 `_` 表示返回值被忽略。

- `icall`（间接）：
  - 语法：`%dst = icall <op_fnptr> (<op_args...>)`
  - 陷阱：操作数不是函数引用。

- `vcall`（虚拟）：
  - 语法：`%dst = vcall <op_obj> <method> (<op_args...>)`
  - 语义：方法解析由模块/宿主定义。
  - 陷阱：缺失方法解析。

参数传递遵循 Rusk 的值/引用语义：
- 原始类型和其他值类型被克隆
- 引用值通过引用传递（克隆引用）
- 只读参数在被调用者中创建只读视图

---

## 8. 终结符（控制流）

每个基本块恰好以一个终结符结束。

- `br`：
  - 语法：`br <block>(<op_args...>)`
  - 语义：求值参数并进入目标块，分配块参数。
  - 陷阱：参数计数 != 目标块参数计数的无效 MIR。

- `cond_br`：
  - 语法：`cond_br <op_cond> <then_block>(<args...>) <else_block>(<args...>)`
  - 陷阱：条件不是 `bool`。
  - 陷阱：参数计数 != 目标块参数计数的无效 MIR。

- `switch`：
  - 语法：
    ```text
    switch <op_value> [
      <pattern> -> <block>,
      ...
    ] <default_block>
    ```
  - 语义：
    - 求值审查对象
    - 按顺序尝试情况
    - 第一次匹配时，进入目标块，将模式绑定作为块参数传递
  - 陷阱：目标块参数计数 != 绑定计数的无效 MIR。

- `return`：
  - 语法：`return <op_value>`

- `trap`：
  - 语法：`trap <message>`
  - 语义：以运行时错误终止执行。

---

## 9. MIR 中的效应系统

### 9.1 处理器栈

MIR 在执行期间维护一个隐式的**处理器栈**。

- `push_handler`：
  - 语法：
    ```text
    push_handler <handler_id> {
      <Interface.method>(<pat_args...>) -> <block>,
      ...
    }
    ```
  - 语义：推送由当前帧拥有的处理器条目。
  - 陷阱：处理器目标块没有 `binding_count + 1` 个参数的无效 MIR（最后一个参数接收延续令牌）。

- `pop_handler`：
  - 语法：`pop_handler`
  - 语义：弹出最近的处理器。
  - 陷阱：不匹配的弹出（顶部处理器不属于当前帧）。

### 9.2 `perform`

- 语法：
  ```text
  %dst = perform <Interface.method>(<op_args...>)
  ```

语义：
1. 求值参数。
2. 从上到下遍历处理器栈。
3. 对于每个处理器条目，按顺序尝试其子句：
   - 如果接口/方法匹配且所有模式匹配参数，则子句匹配。
4. 第一次匹配时：
   - 将当前执行状态捕获为**一次性延续令牌** `k`
     - 捕获的计算由所选处理器的拥有帧**界定**：该拥有帧下面的帧不是捕获栈的一部分
   - 展开到所选处理器的拥有帧
   - 将控制转移到处理器块，带有：
     - 子句的绑定值（按绑定顺序）
     - `k` 作为最后一个块参数
5. 如果没有处理器匹配，陷阱 `"unhandled effect"`。

### 9.3 延续和 `resume`

- 语法：
  ```text
  %dst = resume <op_k> <op_value>
  ```

语义：
- `resume` 消耗延续令牌 `k`（一次性）。
- `resume` 将执行切换到捕获的执行栈，将 `<op_value>` 注入为挂起的 `perform` 的结果。
- 执行继续进行，直到捕获的计算通过从其最底层帧返回而终止。
- 最终返回的值成为 `resume` 的结果并写入 `%dst`。

陷阱：
- 恢复已恢复的令牌
- 恢复非延续值

### 9.4 放弃延续

如果捕获的延续令牌 `k` **从未恢复**并变得不可达（被丢弃），则捕获的计算将永远不会运行。

不立即恢复是允许的：处理器可以存储或返回 `k` 并稍后恢复它（一等延续）。因此，在不恢复的情况下从处理器返回是 MIR 级别机制背后的：
- "中止"行为（丢弃 `k`），以及
- "延迟延续"行为（稍后恢复 `k`）。

---

## 10. 调用约定

v0.2 解释器模型使用正常的调用栈：

- `call` 推送新帧并在被调用者的入口块开始执行。
- `return` 弹出当前帧并返回到调用者。
- 本规范不要求尾调用优化，但 MIR 的结构使得添加它很直接。

---

## 11. 错误和陷阱

MIR 使用 `trap <message>` 和隐式陷阱处理运行时错误，例如：

- 未处理的效应
- 无效的 `resume`（非延续/已恢复）
- 通过只读引用的非法写入
- 数组索引越界
- 缺失字段/操作的错误类型
- 读取未初始化的局部变量

实现可以将陷阱映射到语言级别的错误。

---

## 12. 降级指南（Rusk → MIR）

### 12.1 带有效应分支的 `match`

Rusk：

```rust
match expr {
  () => a,
  @Logger.log(msg) => { print(msg); resume(()) }
}
```

MIR 草图（说明性的）：

```text
block0:
  push_handler H0 { Logger.log(%msg) -> block_log }
  %v = <eval expr>
  pop_handler
  switch %v [unit -> block_done] block_default

block_log(%msg, %k):
  _ = call print(%msg)
  %r = resume %k unit
  return %r
```

注意：
- 处理器仅在 `expr` 的求值期间活动（在 push/pop 之间）。
- 效应分支不参与 `match` 的最终值 `switch`。
- 为了使 `resume` 在有用的边界返回，降级可以将被处理区域包装到辅助函数中，并从周围的代码 `call` 它。

### 12.2 循环

`while cond { body }` 降级为带有回边的 `cond_br`。

---

## 13. 版本控制

MIR 在 v0.2 中有意保持最小化。未来的扩展可能添加：
- 显式堆分配指令和 GC 元数据
- 用于 `switch` 的优化决策树
- 更丰富的值类别和类型引用
- 多次延续
