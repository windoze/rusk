impl<T> Option<T> {
    pub readonly fn is_some() -> bool {
        match self {
            Option::Some(_) => true,
            Option::None => false,
        }
    }

    pub readonly fn is_none() -> bool {
        !self.is_some()
    }

    pub fn map<U>(f: fn(T) -> U) -> Option<U> {
        match self {
            Option::Some(v) => Option::Some(f(v)),
            Option::None => Option::None,
        }
    }

    pub fn and_then<U>(f: fn(T) -> Option<U>) -> Option<U> {
        match self {
            Option::Some(v) => f(v),
            Option::None => Option::None,
        }
    }

    pub fn unwrap() -> T {
        match self {
            Option::Some(v) => v,
            Option::None => panic("called `Option::unwrap()` on `Option::None`"),
        }
    }

    pub fn unwrap_or(default: T) -> T {
        match self {
            Option::Some(v) => v,
            Option::None => default,
        }
    }

    pub fn unwrap_or_else(f: fn() -> T) -> T {
        match self {
            Option::Some(v) => v,
            Option::None => f(),
        }
    }
}
