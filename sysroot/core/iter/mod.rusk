pub interface Iterator {
    type Item;

    fn next() -> Option<Self::Item>;

    fn nth(n: int) -> Option<Self::Item> {
        if n < 0 { return Option::None; };

        let idx = 0;
        loop {
            match self.next() {
                Option::Some(v) => {
                    if idx == n { return Option::Some(v); };
                    idx = idx + 1;
                    ()
                }
                Option::None => { return Option::None; }
            }
        };
        Option::None
    }

    fn last() -> Option<Self::Item> {
        let cur = self.next();
        match cur {
            Option::None => Option::None,
            Option::Some(first) => {
                let out = first;
                loop {
                    match self.next() {
                        Option::Some(v) => { out = v; () }
                        Option::None => { return Option::Some(out); }
                    }
                };
                Option::Some(out)
            }
        }
    }

    fn count() -> int {
        let n = 0;
        loop {
            match self.next() {
                Option::Some(_) => { n = n + 1; () }
                Option::None => { return n; }
            }
        };
        n
    }

    fn find(pred: fn(Self::Item) -> bool) -> Option<Self::Item> {
        loop {
            match self.next() {
                Option::Some(v) => {
                    if pred(v) { return Option::Some(v); };
                    ()
                }
                Option::None => { return Option::None; }
            }
        };
        Option::None
    }

    fn any(pred: fn(Self::Item) -> bool) -> bool {
        loop {
            match self.next() {
                Option::Some(v) => {
                    if pred(v) { return true; };
                    ()
                }
                Option::None => { return false; }
            }
        };
        false
    }

    fn all(pred: fn(Self::Item) -> bool) -> bool {
        loop {
            match self.next() {
                Option::Some(v) => {
                    if !pred(v) { return false; };
                    ()
                }
                Option::None => { return true; }
            }
        };
        true
    }
}

pub interface ToIterator {
    type Item;

    // Convert a container into an `Iterator` interface object.
    //
    // Note: this is intended as the "generic adapter" entry-point. For the built-in container
    // types, the compiler provides built-in impls:
    // - arrays: `xs.to_iter()` lowers to `xs.iter()` (see `array::iter`)
    // - bytes: `bs.to_iter()` lowers to `bs.iter()` (see `bytes::iter`)
    // - string: `s.to_iter()` lowers to `s.chars()` (see `string::chars`)
    readonly fn to_iter() -> Iterator{Item = Self::Item};
}

pub struct ArrayIter<T> {
    xs: readonly [T],
    idx: int,
    len: int,
}

impl<T> ArrayIter<T> {
    pub static fn new(xs: readonly [T]) -> ArrayIter<T> {
        let len = xs.len();
        ArrayIter { xs: xs, idx: 0, len: len }
    }
}

impl<T> Iterator for ArrayIter<T> {
    type Item = readonly T;

    fn next() -> Option<Self::Item> {
        if self.idx < self.len {
            let out = self.xs[self.idx];
            self.idx = self.idx + 1;
            Option::Some(out)
        } else {
            Option::None
        }
    }
}

pub struct BytesIter {
    bs: readonly bytes,
    idx: int,
    len: int,
}

impl BytesIter {
    pub static fn new(bs: readonly bytes) -> BytesIter {
        let len = bs.len();
        BytesIter { bs: bs, idx: 0, len: len }
    }
}

impl Iterator for BytesIter {
    type Item = byte;

    fn next() -> Option<byte> {
        if self.idx < self.len {
            let out = self.bs[self.idx];
            self.idx = self.idx + 1;
            Option::Some(out)
        } else {
            Option::None
        }
    }
}

pub struct CharsIter {
    s: readonly string,
    idx: int,
}

impl CharsIter {
    pub static fn new(s: readonly string) -> CharsIter {
        CharsIter { s: s, idx: 0 }
    }
}

impl Iterator for CharsIter {
    type Item = char;

    fn next() -> Option<char> {
        let next_idx = core::intrinsics::string_next_index(self.s, self.idx);
        if next_idx == -1 { return Option::None; };

        let codepoint = core::intrinsics::string_codepoint_at(self.s, self.idx);
        self.idx = next_idx;
        Option::Some(codepoint.to_char())
    }
}

// Note: built-in container iteration (`for x in [..]`, `for b in bytes`, `for c in string`) is a
// compiler feature. `array::iter`, `bytes::iter`, and `string::chars` provide user-visible
// iterators that implement `core::iter::Iterator`.
